---
layout: distill
title: Cancer subtyping using cNMF and literature markers
description: An example of usage of cNMF to identify cancer subtypes
tags: subtyping
date: 2025-12-17
featured: true
bibliography: 2025-12-30-distill.bib

authors:
  - name: Rafael Oliveira
    url: "https://www.linkedin.com/in/rafael-slo/"
    affiliations:
      name: IKOM, NTNU

# Optionally, you can add a table of contents to your post.
# NOTES:
#   - make sure that TOC names match the actual section names
#     for hyperlinks within the post to work correctly.
#   - we may want to automate TOC generation in the future using
#     jekyll-toc plugin (https://github.com/toshimaru/jekyll-toc).
toc:
  - name: Purpose of this tutorial
    # if a section has subsections, you can add them as follows:
    # subsections:
    #   - name: Example Child Subsection 1
    #   - name: Example Child Subsection 2
  - name: What do we know about SCLC?
  - name: What is cNMF?
  - name: Reading the data
  - name: Running cNMF
  - name: Plotting the results
  - name: Conclusion

# Below is an example of injecting additional post-specific styles.
# If you use this post as a template, delete this _styles block.
_styles: >
  .fake-img {
    background: #bbb;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
  }
  .fake-img p {
    font-family: monospace;
    color: white;
    text-align: left;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
  }
---

## Purpose of this tutorial

Cancer is a complex disease that arises from the accumulation of genetic mutations. These mutations are vast, and differ from one patient to another. This makes it so that cancer is generally seen as a heterogeneous disease. This heterogeneity is reflected in the different subtypes of cancer, which are defined by the mutations that are present in the tumor. These subtypes generally have different clinical features, such as the presence of different mutations, the size of the tumor, and the presence of certain genes (key transcription factors). Additionally, these subtypes can be associated with different responses to treatment. Thus, understanding the molecular biology of different cancer types is key to developing effective treatments and, ultimately, improving patient outcomes. Here, I want to show a brief example of how we can use methods such as cNMF to identify cancer subtypes, particularly in Small-cell lung cancer (SCLC).

---


## What do we know about SCLC?

While this isn't intended to be a comprehensive overview of SCLC, it is important to understand what we already know about the disease, in order to subtype it.

SCLC has long been recognized as one of the most aggressive and heterogeneous cancers. For decades, researchers tried to make sense of this complexity by dividing tumors into “classic” and “variant” forms. But as molecular profiling advanced, a more refined classification emerged: one that highlights the role of dominant transcription factors in shaping tumor identity and behavior. 

Thus, in this tutorial, we can define molecular subtypes as being biologically consistent groups of tumors characterized by three key features:
1. a dominant transcriptional regulator or signaling pathway, 
2. a relatively stable molecular signature across different disease stages and experimental models,
3. clear association with distinct biological behaviors or therapeutic responses observed in clinical settings

Today, four major molecular subtypes are recognized:
- SCLC-A: Driven by ASCL1, accounting for about half of all cases.
- SCLC-N: Defined by NEUROD1, often linked to variant morphology and poorer prognosis.
- SCLC-P: Characterized by POU2F3, representing non-neuroendocrine tumors with tuft cell features.
- SCLC-I: The newest player, marked by an inflamed phenotype with immune-related activity.

### What about SCLC-Y?
Before SCLC-I was proposed, some researchers suggested a fourth subtype called SCLC-Y, supposedly driven by YAP1. YAP1 is a transcriptional co-activator involved in proliferation, survival, and drug resistance. Early studies hinted that it might define a distinct group of tumors. However, subsequent work revealed that YAP1 expression was inconsistent and often low, failing to meet the criteria for a stable, subtype-defining regulator. In other words, YAP1 activity was biologically relevant, but it didn’t reliably carve out a separate molecular identity for SCLC tumors.

### The inflamed alternative: SCLC-I
In 2021, Gay et al. <d-cite key="Gay.2021"></d-cite> proposed the new SCLC-I (Inflamed) subtype. Unlike the neuroendocrine-driven groups, SCLC-I is distinguished by its immune-active microenvironment. These tumors show signatures of interferon signaling, antigen presentation, and T-cell infiltration, features that set them apart biologically and therapeutically.
This inflamed phenotype is particularly exciting because it opens the door to immunotherapy strategies. While classic neuroendocrine SCLC tends to be “immune cold,” SCLC-I tumors may be more responsive to checkpoint inhibitors and other immune-targeted treatments.

For this tutorial, we will attempt to replicate the subtyping done in Gay et al. using a dataset from George et al. (2015) which can be found [here](https://www.cbioportal.org/study/summary?id=sclc_ucologne_2015). This same dataset was used by Gay et al to perform their subtyping.

Here is a summary of what we know about SCLC, from a slide I have created and use to present at conferences:

{% include figure.liquid loading="eager" path="assets/img/subtyping/sclc_info.png" class="img-fluid rounded z-depth-1" %}

---

## What is cNMF?

cNMF is a non-negative matrix factorization (NMF) method that is particularly useful for identifying cancer subtypes. The "c" in cNMF stands for "consensus" which means that the algorithm will run the analysis multiple times and find the most stable, reliable patterns. 

cNMF can be used in a variety of settings, including single-cell RNA (scRNA) in order to look for groups of genes that work together, called gene expression programs. This can be extended to bulk RNA, this time looking for cancer subtypes (here we are talking about samples and not single cells).

The strength of cNMF is in its ability to solve compositional problems. Imagine sitting in a concert hall, listening to an orchestra. If you focus carefully, you start to notice recurring harmonies from the different instruments. That’s exactly what cNMF does with gene expression data. It picks a part the recurring harmonies of genes, the programs that consistently play together. These GEPs (gene expression programs) reveal the functional states of cells or the molecular identity of tumors, turning noise into meaningful biological insight. 

In this tutorial, we will be using the python [cNMF package](https://github.com/dylkot/cNMF) which although has been used for scRNA, can also be used for bulk RNA data.

{% include figure.liquid loading="eager" path="assets/img/subtyping/cnmf.png" class="img-fluid rounded z-depth-1" %}


---
## Reading the data

First, let's import the necessary libraries. 


{% highlight python linenos %}
from cnmf import cNMF
from scipy.stats import zscore
from matplotlib.colors import rgb2hex
import scanpy as sc
import seaborn as sns
import os
from pathlib import Path
import pandas as pd
import anndata as ad
import numpy as np

plt.style.use("bmh")
plt.rcParams.update({"figure.figsize" : (12, 8),
                     "axes.facecolor" : "white",
                     "axes.edgecolor":  "black"})
{% endhighlight %}


Now, lets read the count data. In this case, I am already providing the TPM counts, which were converted from FPKM (original data, can be found [here](https://www.cbioportal.org/study/summary?id=sclc_ucologne_2015). Check this [repository link](https://github.com/Rafael-Silva-Oliveira/subtyping.git) to find all the data necessary to follow this tutorial .

{% highlight python linenos %}
try:
    _base_dir = Path(__file__).resolve().parent
except NameError:
    _base_dir = Path.cwd()

data_file = _base_dir / "data" / "files" / "tpm_counts.csv"

count_data = pd.read_csv(data_file,sep="\t",
    index_col=0,)


clinical_metadata_path = _base_dir / \
    / "data" / "files" / "data_clinical_patient.txt"

clinical_metadata = pd.read_csv(clinical_metadata_path, sep="\t")

clinical_metadata = clinical_metadata.iloc[4:, :]

# Subset clinical metadata with the samples from count_data
clinical_metadata_subset = clinical_metadata[
    clinical_metadata["#Patient Identifier"].isin(count_data.index)
].copy()

clinical_metadata_subset.rename(
    columns={
        "#Patient Identifier": "ID_Sample",
        "UICC Tumor Stage": "tnm_staging",
        "Sex": "sex",
        "Diagnosis Age": "age_at_sample", 
        "Overall Survival (Months)": "time_since_t0_death",
        "Overall Survival Status": "status_os",
    },
    inplace=True,
)

clinical_metadata_subset["status_os"].replace(
    {"1:DECEASED": 1, "0:LIVING": 0}, inplace=True
)

# Add the staging (< III, LS, IV then ES)
clinical_metadata_subset["staging"] = clinical_metadata_subset["tnm_staging"].apply(
    lambda x: "ES" if x == "IV" else "LS" if x != "nan" else "LS"
)

try:
    clinical_metadata_subset.set_index("ID_Sample", inplace=True)
except Exception as e:
    print(f"Error setting index: {e}")

print(
    f"Number of samples per stage: {clinical_metadata_subset.staging.value_counts()}")
{% endhighlight %}

We see that we have 72 patients that are in LS (limited stage, <= TNM stage III) and 9 ES (extensive stage, TNM stage IV). 

And the count_data has this shape (zoom out if unable to see the entire table):
{% highlight python linenos %}
count_data
{% endhighlight %}


{% raw %}
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B2M</th>
      <th>FTL</th>
      <th>HLA-B</th>
      <th>ANXA1</th>
      <th>HLA-DRA</th>
      <th>PFN1</th>
      <th>CTSD</th>
      <th>CD74</th>
      <th>IGLL5</th>
      <th>LYZ</th>
      <th>...</th>
      <th>CYP4F22</th>
      <th>NDST4</th>
      <th>CLEC12B</th>
      <th>IL17C</th>
      <th>AXDND1</th>
      <th>SCN2A</th>
      <th>CNTNAP5</th>
      <th>RNF133</th>
      <th>DNAH8</th>
      <th>YAP1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>sclc_ucologne_2015_S00022</th>
      <td>2162.154403</td>
      <td>2298.411925</td>
      <td>1001.751408</td>
      <td>23.633396</td>
      <td>86.991391</td>
      <td>678.728366</td>
      <td>472.136116</td>
      <td>27.912742</td>
      <td>42.978858</td>
      <td>28.775967</td>
      <td>...</td>
      <td>2.750689</td>
      <td>8.490031</td>
      <td>2.725959</td>
      <td>2.992372</td>
      <td>2.715768</td>
      <td>3.514570</td>
      <td>8.136591</td>
      <td>2.696780</td>
      <td>2.728837</td>
      <td>3.277595</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00035</th>
      <td>3160.088999</td>
      <td>3745.273955</td>
      <td>648.107862</td>
      <td>102.795278</td>
      <td>276.450852</td>
      <td>615.955668</td>
      <td>524.715629</td>
      <td>50.000057</td>
      <td>46.280251</td>
      <td>84.170639</td>
      <td>...</td>
      <td>2.192853</td>
      <td>8.469487</td>
      <td>2.246005</td>
      <td>3.080709</td>
      <td>2.148493</td>
      <td>7.893646</td>
      <td>2.475983</td>
      <td>2.318928</td>
      <td>2.155952</td>
      <td>3.605534</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00050</th>
      <td>2052.014302</td>
      <td>2118.938263</td>
      <td>879.408577</td>
      <td>36.147493</td>
      <td>423.594166</td>
      <td>532.336017</td>
      <td>489.297038</td>
      <td>109.557077</td>
      <td>244.091360</td>
      <td>212.364860</td>
      <td>...</td>
      <td>3.146193</td>
      <td>6.516990</td>
      <td>2.984626</td>
      <td>3.215373</td>
      <td>3.042088</td>
      <td>4.725947</td>
      <td>18.991687</td>
      <td>3.011319</td>
      <td>3.134531</td>
      <td>3.915876</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00213</th>
      <td>9640.167384</td>
      <td>14605.657288</td>
      <td>2289.823486</td>
      <td>121.938662</td>
      <td>2079.767782</td>
      <td>884.827811</td>
      <td>1074.222337</td>
      <td>176.478753</td>
      <td>5425.059394</td>
      <td>2610.552043</td>
      <td>...</td>
      <td>2.681442</td>
      <td>15.147577</td>
      <td>2.421056</td>
      <td>3.124963</td>
      <td>2.386332</td>
      <td>4.895384</td>
      <td>2.558535</td>
      <td>2.451218</td>
      <td>2.389190</td>
      <td>4.352976</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00356</th>
      <td>5004.217605</td>
      <td>4981.908336</td>
      <td>835.222854</td>
      <td>119.778900</td>
      <td>983.900900</td>
      <td>502.215145</td>
      <td>514.830956</td>
      <td>122.104755</td>
      <td>1418.010653</td>
      <td>499.754643</td>
      <td>...</td>
      <td>2.829266</td>
      <td>3.128775</td>
      <td>2.719074</td>
      <td>3.650863</td>
      <td>2.776094</td>
      <td>10.940923</td>
      <td>4.448620</td>
      <td>3.396203</td>
      <td>2.740640</td>
      <td>5.575360</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02375</th>
      <td>6812.104434</td>
      <td>11667.759405</td>
      <td>1509.701805</td>
      <td>1282.925898</td>
      <td>2003.241765</td>
      <td>1048.792635</td>
      <td>1064.024598</td>
      <td>183.230711</td>
      <td>318.635008</td>
      <td>572.531677</td>
      <td>...</td>
      <td>2.093379</td>
      <td>2.280902</td>
      <td>2.106701</td>
      <td>2.041678</td>
      <td>2.030944</td>
      <td>2.036819</td>
      <td>3.085045</td>
      <td>1.997111</td>
      <td>2.072963</td>
      <td>2.719448</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02376</th>
      <td>8251.028221</td>
      <td>3238.868715</td>
      <td>3740.925445</td>
      <td>83.274742</td>
      <td>501.582874</td>
      <td>1147.828117</td>
      <td>389.587217</td>
      <td>58.089660</td>
      <td>541.181302</td>
      <td>293.667019</td>
      <td>...</td>
      <td>2.179461</td>
      <td>6.646879</td>
      <td>2.105514</td>
      <td>2.843782</td>
      <td>2.154875</td>
      <td>5.445269</td>
      <td>6.453248</td>
      <td>2.294543</td>
      <td>2.117667</td>
      <td>3.164042</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02378</th>
      <td>9520.367291</td>
      <td>6724.043881</td>
      <td>2958.637473</td>
      <td>209.366759</td>
      <td>1717.925348</td>
      <td>677.814857</td>
      <td>1175.556034</td>
      <td>183.766750</td>
      <td>267.717238</td>
      <td>523.855194</td>
      <td>...</td>
      <td>2.772599</td>
      <td>2.877168</td>
      <td>2.858701</td>
      <td>3.147568</td>
      <td>2.824992</td>
      <td>2.806729</td>
      <td>3.585936</td>
      <td>2.965653</td>
      <td>2.768039</td>
      <td>6.153518</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02382</th>
      <td>3779.392094</td>
      <td>2525.732381</td>
      <td>577.241843</td>
      <td>161.040659</td>
      <td>226.311589</td>
      <td>307.053940</td>
      <td>236.202220</td>
      <td>49.486211</td>
      <td>557.569124</td>
      <td>478.677608</td>
      <td>...</td>
      <td>3.289202</td>
      <td>3.953085</td>
      <td>3.289202</td>
      <td>6.149953</td>
      <td>3.346079</td>
      <td>4.930345</td>
      <td>8.773256</td>
      <td>3.703050</td>
      <td>3.311947</td>
      <td>7.840243</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02397</th>
      <td>4621.667938</td>
      <td>5300.872063</td>
      <td>1401.574063</td>
      <td>82.634577</td>
      <td>444.025069</td>
      <td>779.949035</td>
      <td>413.593408</td>
      <td>72.070549</td>
      <td>338.586292</td>
      <td>227.066808</td>
      <td>...</td>
      <td>2.991421</td>
      <td>14.824241</td>
      <td>3.086601</td>
      <td>4.139198</td>
      <td>2.982478</td>
      <td>13.696145</td>
      <td>4.118115</td>
      <td>3.192017</td>
      <td>2.981595</td>
      <td>4.707087</td>
    </tr>
  </tbody>
</table>
<p>81 rows × 1294 columns</p>
</div>
{% endraw %}

Let's now create an AnnData object and add the log_tpm_counts to it. This will be useful later on for plotting of the main TFs for each group or subtype.

{% highlight python linenos %}
adata = ad.AnnData(count_data)

adata.obs = clinical_metadata_subset.copy()

adata.var = pd.DataFrame(count_data.columns)

adata.layers["tpm_counts"] = adata.X.copy()

adata.layers["log_tpm_counts"] = np.log1p(count_data.values).copy()

adata.var.set_index(0, inplace=True)
{% endhighlight %}

While one could run cNMF using all the genes from the bulk dataset, only a few thousand genes are needed to identify the subtypes. There are several methods to select the most relevant genes, but for this tutorial, we will use the discovery set from the original publication (Gay et al. 2021). These can be found in the supplementary material of the paper (see DOI above).

{% highlight python linenos %}
# Load genes 1300 discovery set
import openpyxl
final_genes = pd.read_excel(
    _base_dir / "data" / "files" / "1-s2.0-S1535610820306620-mmc2.xlsx",
    header=1,
)
final_genes = final_genes["Unnamed: 0"].tolist()
final_genes.append("YAP1") # adding YAP1 to this list just to test the expression  of YAP1 across the samples to see that it shows a somewhat even expression across identified subtypes. 

missing_genes = [gene for gene in final_genes if gene not in adata.var_names]
print("Missing genes:", missing_genes)

final_genes_filtered = [
    gene for gene in final_genes if gene in adata.var_names]
final_adata = adata[:, final_genes_filtered].copy()
final_adata.X = final_adata.layers["tpm_counts"].copy()
{% endhighlight %}

Lets now crate the TPM counts file that will be used by cNMF.

{% highlight python linenos %}
counts_file_new = "./temp_counts_subtype_identification.txt"
pd.DataFrame(
	adata.X,
	index=adata.obs_names,
	columns=adata.var_names,
).to_csv(counts_file_new, sep="\t")
{% endhighlight %}


Let's now run cNMF. Here, we will test a range of components (from 2 to 8). This is generally done if you don't yet know the optimal number of components/groups/subtypes to use. However, from the literature, we already know for SCLC that the field recognizes this number to be 4, so we will already use this number here. 

## Running cNMF
{% highlight python linenos %}
subtype_col_name="nmf-group-de-novo"
k: int = 4
density_threshold: float = 0.1
components: range = range(2, 8)
mandatory_genes: list = ["ASCL1", "NEUROD1", "POU2F3", "YAP1"] 
n_iter: int = 150
total_workers: int = 1
num_highvar_genes: int = 2000 # number 
ntop_genes: int = 5000
data_save_path: str = "./"
layer = "tpm_counts"

cnmf_obj_new = cNMF(
	output_dir="./cnmf_results_selected_genes", name="nmf_selected_genes"
)

cnmf_obj_new.prepare(
	counts_fn=counts_file_new,
	tpm_fn=f"{_base_dir}/temp_counts_subtype_identification.txt", # note that we can load the TPM counts file directly. Generally, for this package, one can run the raw counts and then it will convert to TPM, but since we don't have access to the raw counts here, we will load the TPM counts directly, which have been calculated from the original FPKM values. 
	components=components,
	n_iter=n_iter,
	num_highvar_genes=num_highvar_genes, # The package may already use this number to use just the top 2000 genes that are highly variable across the samples. 2000 is the default number, but you can change it to something else. In this case, the total number of genes is around 1300, so this number being 2000 won't do much harm.
)

cnmf_obj_new.factorize(worker_i=0, total_workers=total_workers)

cnmf_obj_new.combine()
{% endhighlight %}

This plot will show the stability and error for each of the K tested (in our case, from 2 to 7 components). We see that the optimal number of components is 4, which offers the best stability and lowest error, which once again confirms the literature.

{% highlight python linenos %}
cnmf_obj_new.consensus(
	k=k,
	density_threshold=density_threshold,
	show_clustering=True,
	close_clustergram_fig=False,
)

cnmf_obj_new.k_selection_plot()
{% endhighlight %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/k4.png" class="img-fluid rounded z-depth-1" %}


{% highlight python linenos %}
usage_matrix_nmf_var, gep_scores_nmf_var, gep_tpm_nmf_var, topgenes_nmf_var = (
	cnmf_obj_new.load_results(K=k, density_threshold=density_threshold)
) # capture the usage matrix, GEP scores, etc.
{% endhighlight %}


Now that we have calculated the usage matrix, we can merge it with the original AnnData object. This is a normalized value, that sums to 1 across our selected K. In this case, we will have 4 new columns, from 1 to 4, representing each of the 4 components. 

We can also then take the maximum value of the usage matrix, and give a categorical assignment to each sample based on the maximum value. This is useful for other downstream analysis, such as differential expression analysis, boxplot visualizations, etc.

{% highlight python linenos %}

adata_nmf = adata.copy()
adata_nmf.obs = pd.merge(
	left=adata_nmf.obs,
	right=usage_matrix_nmf_var,
	how="left",
	left_index=True,
	right_index=True,
)
top_genes_nmf = []

print(f"Selecting top {ntop_genes} genes for each subtype")
for gep in gep_scores_nmf_var.columns:
	top_genes_nmf.append(
		list(
			gep_scores_nmf_var.sort_values(by=gep, ascending=False).index[
				:ntop_genes
			]
		)
	)

top_genes_nmf = pd.DataFrame(top_genes_nmf, index=gep_scores_nmf_var.columns).T

for col in top_genes_nmf.columns:
	print([g for g in top_genes_nmf[col] if g in mandatory_genes])

adata_nmf.obs[subtype_col_name] = usage_matrix_nmf_var.idxmax(
	axis=1
).astype(str)

print(
	f"Count of groups: {adata_nmf.obs[subtype_col_name].value_counts()}"
)

gene_df = pd.DataFrame({"gene": adata_nmf.var_names.tolist()})

print(
	f"Saving top {ntop_genes} NMF genes to {data_save_path + 'nmf_genes.csv'}"
)
gene_df.to_csv(data_save_path + "nmf_genes.csv")


adata_nmf.obs[["nmf-group-de-novo",1,2,3,4]]
{% endhighlight %}

Our adata.obs now has the subtype scores and the `nmf-group-de-novo` which is essentially the maximum of the subtype scores, so we can associate a subtype for each sample (zoom out if unable to see the entire table). Doing a simple `.value_counts()` on this column will give us the number of samples per subtype which goes as follows:


{% raw %}
<table border="1">
  <tr>
    <th>Index</th>
    <th>Value</th>
  </tr>
  <tr>
    <td>1</td>
    <td>29</td>
  </tr>
  <tr>
    <td>2</td>
    <td>21</td>
  </tr>
  <tr>
    <td>3</td>
    <td>18</td>
  </tr>
  <tr>
    <td>4</td>
    <td>13</td>
  </tr>
</table>
{% endraw %}

Additionally, the subtype scores, as these are normalized, they can be interpreted as proportions of a given subtype across each sample. This is particularly useful, as we can do correlations with other biomarkers we may have, or to simply indicate the proportion of subtypes for each sample since, realistically, one patient is likely to have multiple subtypes at once, within a single sample. 

One could also combine these scores and define thresholds to define "mixed" subtypes (e.g. A/N, A/I, etc). This can be particularly useful if we want to be a bit more specific about the subtypes we define, especially in SCLC, as research suggests that the subtypes are not always clear-cut <d-cite key="Velut.2024"></d-cite> and an otherwise "non-inflamed" SCLC subtype may still have some imune components that give it an improved treatment response in combination with immune-based therapies <d-cite key="Nabet.2024"></d-cite>. Considering these nuances is important if we want to use this information to guide treatment decisions.

{% raw %}
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>nmf-group-de-novo</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
    <tr>
      <th>ID_Sample</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>sclc_ucologne_2015_S00022</th>
      <td>2</td>
      <td>0.472633</td>
      <td>0.506275</td>
      <td>0.006064</td>
      <td>0.015028</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00035</th>
      <td>1</td>
      <td>0.836964</td>
      <td>0.000000</td>
      <td>0.106799</td>
      <td>0.056237</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00050</th>
      <td>2</td>
      <td>0.174711</td>
      <td>0.798140</td>
      <td>0.027149</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00213</th>
      <td>3</td>
      <td>0.417614</td>
      <td>0.000000</td>
      <td>0.539206</td>
      <td>0.043180</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00356</th>
      <td>1</td>
      <td>0.427478</td>
      <td>0.282972</td>
      <td>0.198701</td>
      <td>0.090849</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02375</th>
      <td>4</td>
      <td>0.034423</td>
      <td>0.000000</td>
      <td>0.384087</td>
      <td>0.581490</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02376</th>
      <td>1</td>
      <td>0.656548</td>
      <td>0.029480</td>
      <td>0.260617</td>
      <td>0.053356</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02378</th>
      <td>3</td>
      <td>0.175559</td>
      <td>0.215421</td>
      <td>0.337799</td>
      <td>0.271221</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02382</th>
      <td>2</td>
      <td>0.228773</td>
      <td>0.581242</td>
      <td>0.023989</td>
      <td>0.165996</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02397</th>
      <td>1</td>
      <td>0.622625</td>
      <td>0.079786</td>
      <td>0.144879</td>
      <td>0.152710</td>
    </tr>
  </tbody>
</table>
<p>81 rows × 5 columns</p>
</div>
{% endraw %}


## Plotting the results
Now that we have our subtypes, it is time to plot some of the known markers from SCLC and see which group has highest expression for each of the key markets. To explore this, let's do some boxplots, showing the groups (i.e. subtypes) against key genes using the log_tpm_counts that we calculated earlier.
{% highlight python linenos %}

# Start by creating a dataframe with the log_tpm_counts and the ID_Samples
key_markers_boxplot = pd.DataFrame(
	adata_nmf.layers["log_tpm_counts"],
	columns=adata_nmf.var_names,
	index=adata_nmf.obs_names,
)

# Subset just the key genes
key_markers_boxplot = key_markers_boxplot[["ASCL1", "NEUROD1", "POU2F3", "YAP1"]]

# Add the NMF grouping we calculated earlier using cNMF
merged_data = key_markers_boxplot.merge(adata_nmf.obs[["nmf-group-de-novo"]], on="ID_Sample", how="inner")

# Now, plot each of the key genes against the NMF groups
for key_genes in ["ASCL1", "NEUROD1", "YAP1", "POU2F3"]:
	ax = sns.boxplot(x="nmf-group-de-novo", y=key_genes, data=merged_data, palette="Set2")

	ax.set(xlabel="NMF groups", ylabel="log TPM counts")
	ax.set_title(f"Boxplot of {key_genes} expression per NMF group", fontsize=20)
	ax.set_ylabel("log TPM counts")
	ax.set_xlabel("NMF groups")	
	plt.show()
	plt.close()
{% endhighlight %}

This will give the following boxplots:

{% include figure.liquid loading="eager" path="assets/img/subtyping/ASCL1.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/NEUROD1.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/YAP1.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/pou2f3.png" class="img-fluid rounded z-depth-1" %}

This gives us a good idea of which subtypes are associated with each of the key genes. Now, ideally, if we have the raw counts, the next step is to do some differential expression analysis to see which of the key markers from SCLC (or another cancer being analyzed) are differentially expressed between the subtypes. To do this, one can use the `pydeseq2` package, which is a popular tool for differential expression analysis in python. While it is not the focus of this tutorial, I will bring another tutorial later on showing an example of how to use `pydeseq2` and a modification to do both `one-vs-one` and `one-vs-all` comparisons.

The next step is to do some more visualizations that will help us understand the subtypes better, this time using gene sets and a radial plot. The gene sets we will use (see code below) are **NE** (neuroendocrine), **nonNE** (non-neuroendocrine), **T-eff** (tumor-effector), **B/PC** (B-cell and plasma cell), and **APM** (antigen processing and presentation) and **Checkpt** (immune checkpoint).

Additionally, we will also use a mapping between the numerical NMF groups, and the subtypes based on the boxplots made earlier. We see that cluster 1 has higher expression for ASCL1, so we associate this cluster to A subtype. Cluster 2 has higher expression for NEUROD1, so we associate this cluster to N subtype. Cluster 4 has higher expression for POU2F3, so we associate this cluster to P subtype. The last cluster, cluster 3 can, can be associated with the Inflammed subtype. We see that the expression of YAP1 is not sufficient to define a subtype on its own. 


{% highlight python linenos %}
adata_analysis_radial = adata_nmf.copy()
adata_analysis_radial.obs = adata_analysis_radial.obs[
    [
        1,
        2,
        3,
        4,
        "nmf-group-de-novo",
    ]
]

# Since we already have the log_tpm_counts, we can use them directly, and then only scale them
adata_analysis_radial.X = adata_analysis_radial.layers["log_tpm_counts"].copy()
sc.pp.scale(adata_analysis_radial)

# These will be the gene sets we will use
gene_categories = {
    "NE": ["CHGA", "DLL3", "NEUROD1", "INSM1", "ASCL1"],
    "nonNE": ["YAP1", "POU2F3", "MYC", "REST"],
    "T-eff": [
        "CD8A",
        "GZMA",
        "GZMB",
        "PRF1",
        "IFNG",
        "CXCL9",
        "CXCL10",
        "TBX21",
    ],
    "B/PC": ["CD79A", "MS4A1", "MZB1", "JCHAIN"],
    "APM": ["TAP1", "TAP2", "B2M", "HLA-A", "HLA-C"],
    "Checkpt": ["PDCD1", "CD274", "LAG3", "CTLA4", "BTLA", "TIGIT"],
}

# Compute scores for each category
for category, genes in gene_categories.items():
    sc.tl.score_genes(adata_analysis_radial, genes,
                      score_name=f"{category}_score")

# Calculate mean scores for each NMF group
nmf_scores = adata_analysis_radial.obs.groupby("nmf-group-de-novo").mean()

# Normalize scores (Z-score across subsets)
score_columns = [f"{cat}_score" for cat in gene_categories.keys()]
nmf_scores_norm = (
    nmf_scores[score_columns] - nmf_scores[score_columns].mean()
) / nmf_scores[score_columns].std()

# Define NMF labels
nmf_labels = {
    "1": "A",
    "2": "N",
    "3": "I",
    "4": "P",
}

# Colors for each NMF group
colors = ["#8A7EB5", "#67C28E", "#E75480", "#FFA500"]
color_map = {
    "1": "#4169E1",  # A - RoyalBlue (cold)
    "2": "#008080",  # N - Teal (cold)
    "3": "#DC143C",  # I-nNE - Crimson (warm)
    "4": "#FF8C00",  # I-NE - DarkOrange (warm)
}

fig = plt.figure(figsize=(8, 8))
ax = plt.subplot(111, projection="polar")

# Prepare angles
categories = list(gene_categories.keys())
N = len(categories)
angles = [n / float(N) * 2 * np.pi for n in range(N)]
angles += angles[:1]  # Complete the loop

# Plot each group
for nmf_group in sorted(nmf_scores_norm.index):
    data = nmf_scores_norm.loc[nmf_group, score_columns].to_frame().T
    values = data.values.flatten().tolist()
    values += values[:1]  # Complete the loop

    label = nmf_labels.get(nmf_group, nmf_group)
    color = color_map[nmf_group]

    ax.plot(
        angles,
        values,
        linewidth=2.5,
        linestyle="solid",
        label=f"NMF{nmf_group}: {label}",
        color=color,
    )
    ax.fill(angles, values, color=color, alpha=0.2)

# Format the plot
ax.set_theta_offset(np.pi / 2)
ax.set_theta_direction(-1)

ax.set_xticks(angles[:-1])
ax.set_xticklabels(categories, size=15)
ax.set_yticklabels([])  # Hide radial labels
ax.grid(True, color="grey", alpha=0.3)
ax.spines["polar"].set_visible(False)

ax.legend(loc="upper right", bbox_to_anchor=(1.3, 1.1), fontsize=12)
ax.set_title("Radial plot of NMF groups", size=20, y=1.1)
plt.tight_layout()


plt.show()
{% endhighlight %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/radial.png" class="img-fluid rounded z-depth-1" %}

---

## Conclusion

And there you have it! We have now identified the molecular subtypes of SCLC using cNMF, with matching distributions and TFs expression profiles, compared to the original publication. 

There is a lot we can do with this information. Cell type devoncolution on the bulk RNA data to further evaluate cell type composition, survival analysis, differential expression analysis, functional enrichment analysis, etc. I plan on bringing more tutorials across all things related to transcriptomics, so stay tuned!

