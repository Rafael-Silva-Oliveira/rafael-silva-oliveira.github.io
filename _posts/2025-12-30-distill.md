---
layout: distill
title: Cancer subtyping using cNMF and literature markers
description: An example of usage of cNMF to identify cancer subtypes
tags: subtyping
date: 2025-12-12
featured: true

authors:
  - name: Rafael Oliveira
    url: "https://www.linkedin.com/in/rafael-slo/"
    affiliations:
      name: IKOM, NTNU

# Optionally, you can add a table of contents to your post.
# NOTES:
#   - make sure that TOC names match the actual section names
#     for hyperlinks within the post to work correctly.
#   - we may want to automate TOC generation in the future using
#     jekyll-toc plugin (https://github.com/toshimaru/jekyll-toc).
toc:
  - name: Purpose of this tutorial
    # if a section has subsections, you can add them as follows:
    # subsections:
    #   - name: Example Child Subsection 1
    #   - name: Example Child Subsection 2
  - name: What do we know about SCLC?
  - name: What is cNMF?
  - name: Reading the data
  - name: Running cNMF
  - name: Plotting the results
  - name: Citations

# Below is an example of injecting additional post-specific styles.
# If you use this post as a template, delete this _styles block.
_styles: >
  .fake-img {
    background: #bbb;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
  }
  .fake-img p {
    font-family: monospace;
    color: white;
    text-align: left;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
  }
---

## Purpose of this tutorial

---


## What do we know about SCLC?

{% include figure.liquid loading="eager" path="assets/img/subtyping/sclc_info.png" class="img-fluid rounded z-depth-1" %}

---

## What is cNMF?

---
## Reading the data

---

{% highlight python linenos %}
import os.path
from lifelines import CoxPHFitter
from lifelines.statistics import logrank_test, multivariate_logrank_test
from lifelines import KaplanMeierFitter
import shutil
from cnmf import cNMF
from tqdm import tqdm
from scipy.stats import zscore
from pydeseq2.ds import DeseqStats
from pydeseq2.dds import DeseqDataSet
from matplotlib.colors import rgb2hex
import itertools
from scipy import stats
import scanpy as sc
from matplotlib.lines import Line2D
from matplotlib.gridspec import GridSpec
import matplotlib.pyplot as plt
import seaborn as sns
import os
from pathlib import Path
import decoupler as dc
import pandas as pd
import anndata as ad
import re
import numpy as np
from scipy.sparse import csr_matrix
from pybiomart import Server
from scipy.stats import gmean
import json
import joblib
import matplotlib.pyplot as plt

plt.style.use("bmh")
plt.rcParams.update({"figure.figsize" : (12, 8),
                     "axes.facecolor" : "white",
                     "axes.edgecolor":  "black"})
{% endhighlight %}

{% highlight python linenos %}
try:
    _base_dir = Path(__file__).resolve().parent
except NameError:
    _base_dir = Path.cwd()

# The data folder is a subdirectory named 'EGAD00001001244' next to this script.
data_file = _base_dir / "EGAD00001001244" / "tpm_counts.csv"

count_data = pd.read_csv(data_file,sep="\t",
    index_col=0,)


clinical_metadata_path = _base_dir / \
    "EGAD00001001244" / "data_clinical_patient.txt"

clinical_metadata = pd.read_csv(clinical_metadata_path, sep="\t")

clinical_metadata = clinical_metadata.iloc[4:, :]

# Subset clinical metadata with the samples from count_data
clinical_metadata_subset = clinical_metadata[
    clinical_metadata["#Patient Identifier"].isin(count_data.index)
].copy()

clinical_metadata_subset.rename(
    columns={
        "#Patient Identifier": "ID_Sample",
        "UICC Tumor Stage": "tnm_staging",
        "Sex": "sex",
        "Diagnosis Age": "age_at_sample",
        "Overall Survival (Months)": "time_since_t0_death",
        "Overall Survival Status": "status_os",
    },
    inplace=True,
)

clinical_metadata_subset["status_os"].replace(
    {"1:DECEASED": 1, "0:LIVING": 0}, inplace=True
)

# Add the staging (< III, LS, IV then ES)
clinical_metadata_subset["staging"] = clinical_metadata_subset["tnm_staging"].apply(
    lambda x: "ES" if x == "IV" else "LS" if x != "nan" else "LS"
)

try:
    clinical_metadata_subset.set_index("ID_Sample", inplace=True)
except Exception as e:
    print(f"Error setting index: {e}")

print(
    f"Number of samples per stage: {clinical_metadata_subset.staging.value_counts()}")
{% endhighlight %}
{% highlight python linenos %}
count_data
{% endhighlight %}

{% raw %}
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B2M</th>
      <th>FTL</th>
      <th>HLA-B</th>
      <th>ANXA1</th>
      <th>HLA-DRA</th>
      <th>PFN1</th>
      <th>CTSD</th>
      <th>CD74</th>
      <th>IGLL5</th>
      <th>LYZ</th>
      <th>...</th>
      <th>CYP4F22</th>
      <th>NDST4</th>
      <th>CLEC12B</th>
      <th>IL17C</th>
      <th>AXDND1</th>
      <th>SCN2A</th>
      <th>CNTNAP5</th>
      <th>RNF133</th>
      <th>DNAH8</th>
      <th>YAP1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>sclc_ucologne_2015_S00022</th>
      <td>2162.154403</td>
      <td>2298.411925</td>
      <td>1001.751408</td>
      <td>23.633396</td>
      <td>86.991391</td>
      <td>678.728366</td>
      <td>472.136116</td>
      <td>27.912742</td>
      <td>42.978858</td>
      <td>28.775967</td>
      <td>...</td>
      <td>2.750689</td>
      <td>8.490031</td>
      <td>2.725959</td>
      <td>2.992372</td>
      <td>2.715768</td>
      <td>3.514570</td>
      <td>8.136591</td>
      <td>2.696780</td>
      <td>2.728837</td>
      <td>3.277595</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00035</th>
      <td>3160.088999</td>
      <td>3745.273955</td>
      <td>648.107862</td>
      <td>102.795278</td>
      <td>276.450852</td>
      <td>615.955668</td>
      <td>524.715629</td>
      <td>50.000057</td>
      <td>46.280251</td>
      <td>84.170639</td>
      <td>...</td>
      <td>2.192853</td>
      <td>8.469487</td>
      <td>2.246005</td>
      <td>3.080709</td>
      <td>2.148493</td>
      <td>7.893646</td>
      <td>2.475983</td>
      <td>2.318928</td>
      <td>2.155952</td>
      <td>3.605534</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00050</th>
      <td>2052.014302</td>
      <td>2118.938263</td>
      <td>879.408577</td>
      <td>36.147493</td>
      <td>423.594166</td>
      <td>532.336017</td>
      <td>489.297038</td>
      <td>109.557077</td>
      <td>244.091360</td>
      <td>212.364860</td>
      <td>...</td>
      <td>3.146193</td>
      <td>6.516990</td>
      <td>2.984626</td>
      <td>3.215373</td>
      <td>3.042088</td>
      <td>4.725947</td>
      <td>18.991687</td>
      <td>3.011319</td>
      <td>3.134531</td>
      <td>3.915876</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00213</th>
      <td>9640.167384</td>
      <td>14605.657288</td>
      <td>2289.823486</td>
      <td>121.938662</td>
      <td>2079.767782</td>
      <td>884.827811</td>
      <td>1074.222337</td>
      <td>176.478753</td>
      <td>5425.059394</td>
      <td>2610.552043</td>
      <td>...</td>
      <td>2.681442</td>
      <td>15.147577</td>
      <td>2.421056</td>
      <td>3.124963</td>
      <td>2.386332</td>
      <td>4.895384</td>
      <td>2.558535</td>
      <td>2.451218</td>
      <td>2.389190</td>
      <td>4.352976</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S00356</th>
      <td>5004.217605</td>
      <td>4981.908336</td>
      <td>835.222854</td>
      <td>119.778900</td>
      <td>983.900900</td>
      <td>502.215145</td>
      <td>514.830956</td>
      <td>122.104755</td>
      <td>1418.010653</td>
      <td>499.754643</td>
      <td>...</td>
      <td>2.829266</td>
      <td>3.128775</td>
      <td>2.719074</td>
      <td>3.650863</td>
      <td>2.776094</td>
      <td>10.940923</td>
      <td>4.448620</td>
      <td>3.396203</td>
      <td>2.740640</td>
      <td>5.575360</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02375</th>
      <td>6812.104434</td>
      <td>11667.759405</td>
      <td>1509.701805</td>
      <td>1282.925898</td>
      <td>2003.241765</td>
      <td>1048.792635</td>
      <td>1064.024598</td>
      <td>183.230711</td>
      <td>318.635008</td>
      <td>572.531677</td>
      <td>...</td>
      <td>2.093379</td>
      <td>2.280902</td>
      <td>2.106701</td>
      <td>2.041678</td>
      <td>2.030944</td>
      <td>2.036819</td>
      <td>3.085045</td>
      <td>1.997111</td>
      <td>2.072963</td>
      <td>2.719448</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02376</th>
      <td>8251.028221</td>
      <td>3238.868715</td>
      <td>3740.925445</td>
      <td>83.274742</td>
      <td>501.582874</td>
      <td>1147.828117</td>
      <td>389.587217</td>
      <td>58.089660</td>
      <td>541.181302</td>
      <td>293.667019</td>
      <td>...</td>
      <td>2.179461</td>
      <td>6.646879</td>
      <td>2.105514</td>
      <td>2.843782</td>
      <td>2.154875</td>
      <td>5.445269</td>
      <td>6.453248</td>
      <td>2.294543</td>
      <td>2.117667</td>
      <td>3.164042</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02378</th>
      <td>9520.367291</td>
      <td>6724.043881</td>
      <td>2958.637473</td>
      <td>209.366759</td>
      <td>1717.925348</td>
      <td>677.814857</td>
      <td>1175.556034</td>
      <td>183.766750</td>
      <td>267.717238</td>
      <td>523.855194</td>
      <td>...</td>
      <td>2.772599</td>
      <td>2.877168</td>
      <td>2.858701</td>
      <td>3.147568</td>
      <td>2.824992</td>
      <td>2.806729</td>
      <td>3.585936</td>
      <td>2.965653</td>
      <td>2.768039</td>
      <td>6.153518</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02382</th>
      <td>3779.392094</td>
      <td>2525.732381</td>
      <td>577.241843</td>
      <td>161.040659</td>
      <td>226.311589</td>
      <td>307.053940</td>
      <td>236.202220</td>
      <td>49.486211</td>
      <td>557.569124</td>
      <td>478.677608</td>
      <td>...</td>
      <td>3.289202</td>
      <td>3.953085</td>
      <td>3.289202</td>
      <td>6.149953</td>
      <td>3.346079</td>
      <td>4.930345</td>
      <td>8.773256</td>
      <td>3.703050</td>
      <td>3.311947</td>
      <td>7.840243</td>
    </tr>
    <tr>
      <th>sclc_ucologne_2015_S02397</th>
      <td>4621.667938</td>
      <td>5300.872063</td>
      <td>1401.574063</td>
      <td>82.634577</td>
      <td>444.025069</td>
      <td>779.949035</td>
      <td>413.593408</td>
      <td>72.070549</td>
      <td>338.586292</td>
      <td>227.066808</td>
      <td>...</td>
      <td>2.991421</td>
      <td>14.824241</td>
      <td>3.086601</td>
      <td>4.139198</td>
      <td>2.982478</td>
      <td>13.696145</td>
      <td>4.118115</td>
      <td>3.192017</td>
      <td>2.981595</td>
      <td>4.707087</td>
    </tr>
  </tbody>
</table>
<p>81 rows Ã— 1294 columns</p>
</div>
{% endraw %}

{% highlight python linenos %}
adata = ad.AnnData(count_data)

adata.obs = clinical_metadata_subset.copy()

adata.var = pd.DataFrame(count_data.columns)

adata.layers["tpm_counts"] = adata.X.copy()

adata.layers["log_tpm_counts"] = np.log1p(count_data.values).copy()

adata.layers["z_log_tpm_counts"] = zscore(
    adata.layers["log_tpm_counts"], axis=0).copy()
adata.var.set_index(0, inplace=True)
{% endhighlight %}
{% highlight python linenos %}
# Load genes 1300 discovery set
import openpyxl
final_genes = pd.read_excel(
    f"{_base_dir}/EGAD00001001244/1-s2.0-S1535610820306620-mmc2.xlsx",
    header=1,
)
final_genes = final_genes["Unnamed: 0"].tolist()
final_genes.append("YAP1")
# final_genes.extend(["ZEB1", "ZEB2", "SNAI1", "TWIST1"])
missing_genes = [gene for gene in final_genes if gene not in adata.var_names]
print("Missing genes:", missing_genes)

final_genes_filtered = [
    gene for gene in final_genes if gene in adata.var_names]
final_adata = adata[:, final_genes_filtered].copy()
final_adata.X = final_adata.layers["tpm_counts"].copy()
{% endhighlight %}

{% highlight python linenos %}
counts_file_new = "./temp_counts_subtype_identification.txt"
pd.DataFrame(
	adata.X,
	index=adata.obs_names,
	columns=adata.var_names,
).to_csv(counts_file_new, sep="\t")
{% endhighlight %}


## Running cNMF
{% highlight python linenos %}
subtype_col_name="nmf-group-de-novo"
k: int = 4
density_threshold: float = 0.1
components: range = range(2, 8)
mandatory_genes: list = ["ASCL1", "NEUROD1", "POU2F3", "YAP1"]
n_iter: int = 150
total_workers: int = 1
num_highvar_genes: int = 2000
ntop_genes: int = 5000
data_save_path: str = "./"
layer = "tpm_counts"

cnmf_obj_new = cNMF(
	output_dir="./cnmf_results_selected_genes", name="nmf_selected_genes"
)

cnmf_obj_new.prepare(
	counts_fn=counts_file_new,
	tpm_fn=f"{_base_dir}/temp_counts_subtype_identification.txt",
	components=components,
	n_iter=n_iter,
	num_highvar_genes=num_highvar_genes,
)

cnmf_obj_new.factorize(worker_i=0, total_workers=total_workers)

cnmf_obj_new.combine()

cnmf_obj_new.consensus(
	k=k,
	density_threshold=density_threshold,
	show_clustering=True,
	close_clustergram_fig=False,
)

cnmf_obj_new.k_selection_plot()

usage_matrix_nmf_var, gep_scores_nmf_var, gep_tpm_nmf_var, topgenes_nmf_var = (
	cnmf_obj_new.load_results(K=k, density_threshold=density_threshold)
)

adata_nmf = adata.copy()
adata_nmf.obs = pd.merge(
	left=adata_nmf.obs,
	right=usage_matrix_nmf_var,
	how="left",
	left_index=True,
	right_index=True,
)
top_genes_nmf = []

print(f"Selecting top {ntop_genes} genes for each subtype")
for gep in gep_scores_nmf_var.columns:
	top_genes_nmf.append(
		list(
			gep_scores_nmf_var.sort_values(by=gep, ascending=False).index[
				:ntop_genes
			]
		)
	)

top_genes_nmf = pd.DataFrame(top_genes_nmf, index=gep_scores_nmf_var.columns).T

for col in top_genes_nmf.columns:
	print([g for g in top_genes_nmf[col] if g in mandatory_genes])

adata_nmf.obs[subtype_col_name] = usage_matrix_nmf_var.idxmax(
	axis=1
).astype(str)

print(
	f"Count of groups: {adata_nmf.obs[subtype_col_name].value_counts()}"
)

gene_df = pd.DataFrame({"gene": adata_nmf.var_names.tolist()})

print(
	f"Saving top {ntop_genes} NMF genes to {data_save_path + 'nmf_genes.csv'}"
)
gene_df.to_csv(data_save_path + "nmf_genes.csv")


---

adata_nmf.obs
{% endhighlight %}


## Plotting the results
Now that we have our subtypes, it is time to plot some of the known markers from SCLC and see which group has highest expression for each of the key markets. To explore this, let's do some boxplots, showing the groups (i.e. subtypes) against key genes using the log_tpm_counts that we calculated earlier.
{% highlight python linenos %}

# Start by creating a dataframe with the log_tpm_counts and the ID_Samples
key_markers_boxplot = pd.DataFrame(
	adata_nmf.layers["log_tpm_counts"],
	columns=adata_nmf.var_names,
	index=adata_nmf.obs_names,
)

# Subset just the key genes
key_markers_boxplot = key_markers_boxplot[["ASCL1", "NEUROD1", "POU2F3", "YAP1"]]

# Add the NMF grouping we calculated earlier using cNMF
merged_data = key_markers_boxplot.merge(adata_nmf.obs[["nmf-group-de-novo"]], on="ID_Sample", how="inner")

# Now, plot each of the key genes against the NMF groups
for key_genes in ["ASCL1", "NEUROD1", "YAP1", "POU2F3"]:
	ax = sns.boxplot(x="nmf-group-de-novo", y=key_genes, data=merged_data, palette="Set2")

	ax.set(xlabel="NMF groups", ylabel="log TPM counts")
	ax.set_title(f"Boxplot of {key_genes} expression per NMF group", fontsize=20)
	ax.set_ylabel("log TPM counts")
	ax.set_xlabel("NMF groups")	
	plt.show()
	plt.close()
{% endhighlight %}

This will give the following boxplots:

{% include figure.liquid loading="eager" path="assets/img/subtyping/ASCL1.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/NEUROD1.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/YAP1.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/pou2f3.png" class="img-fluid rounded z-depth-1" %}

This gives us a good idea of which subtypes are associated with each of the key genes. Now, ideally, if we have the raw counts, the next step is to do some differential expression analysis to see which of the key markers from SCLC (or another cancer being analyzed) are differentially expressed between the subtypes. To do this, one can use the `pydeseq2` package, which is a popular tool for differential expression analysis in python. While it is not the focus of this tutorial, I will bring another tutorial later on showing an example of how to use `pydeseq2` and a modification to do both `one-vs-one` and `one-vs-all` comparisons.

The next step is to do some more visualizations that will help us understand the subtypes better, this time using gene sets and a radial plot. The gene sets we will use (see code below) are **NE** (neuroendocrine), **nonNE** (non-neuroendocrine), **T-eff** (tumor-effector), **B/PC** (B-cell and plasma cell), and **APM** (antigen processing and presentation) and **Checkpt** (immune checkpoint).

Additionally, we will also use a mapping between the numerical NMF groups, and the subtypes based on the boxplots made earlier. We see that cluster 1 has higher expression for ASCL1, so we associate this cluster to A subtype. Cluster 2 has higher expression for NEUROD1, so we associate this cluster to N subtype. Cluster 4 has higher expression for POU2F3, so we associate this cluster to P subtype. The last cluster, cluster 3 can, for now, be associated with the I subtype, even though the expression levels are not as visually different as the other markers.This will be done using a dictionary called `nmf_labels` that will map the NMF groups to the subtypes.


{% highlight python linenos %}
adata_analysis_radial = adata_nmf.copy()
adata_analysis_radial.obs = adata_analysis_radial.obs[
    [
        1,
        2,
        3,
        4,
        "nmf-group-de-novo",
    ]
]

# Since we already have the log_tpm_counts, we can use them directly, and then only scale them
adata_analysis_radial.X = adata_analysis_radial.layers["log_tpm_counts"].copy()
sc.pp.scale(adata_analysis_radial)

# These will be the gene sets we will use
gene_categories = {
    "NE": ["CHGA", "DLL3", "NEUROD1", "INSM1", "ASCL1"],
    "nonNE": ["YAP1", "POU2F3", "MYC", "REST"],
    "T-eff": [
        "CD8A",
        "GZMA",
        "GZMB",
        "PRF1",
        "IFNG",
        "CXCL9",
        "CXCL10",
        "TBX21",
    ],
    "B/PC": ["CD79A", "MS4A1", "MZB1", "JCHAIN"],
    "APM": ["TAP1", "TAP2", "B2M", "HLA-A", "HLA-C"],
    "Checkpt": ["PDCD1", "CD274", "LAG3", "CTLA4", "BTLA", "TIGIT"],
}

# Compute scores for each category
for category, genes in gene_categories.items():
    sc.tl.score_genes(adata_analysis_radial, genes,
                      score_name=f"{category}_score")

# Calculate mean scores for each NMF group
nmf_scores = adata_analysis_radial.obs.groupby("nmf-group-de-novo").mean()

# Normalize scores (Z-score across subsets)
score_columns = [f"{cat}_score" for cat in gene_categories.keys()]
nmf_scores_norm = (
    nmf_scores[score_columns] - nmf_scores[score_columns].mean()
) / nmf_scores[score_columns].std()

# Define NMF labels
nmf_labels = {
    "1": "A",
    "2": "N",
    "3": "I",
    "4": "P",
}

# Colors for each NMF group
colors = ["#8A7EB5", "#67C28E", "#E75480", "#FFA500"]
color_map = {
    "1": "#4169E1",  # A - RoyalBlue (cold)
    "2": "#008080",  # N - Teal (cold)
    "3": "#DC143C",  # I-nNE - Crimson (warm)
    "4": "#FF8C00",  # I-NE - DarkOrange (warm)
}

fig = plt.figure(figsize=(8, 8))
ax = plt.subplot(111, projection="polar")

# Prepare angles
categories = list(gene_categories.keys())
N = len(categories)
angles = [n / float(N) * 2 * np.pi for n in range(N)]
angles += angles[:1]  # Complete the loop

# Plot each group
for nmf_group in sorted(nmf_scores_norm.index):
    data = nmf_scores_norm.loc[nmf_group, score_columns].to_frame().T
    values = data.values.flatten().tolist()
    values += values[:1]  # Complete the loop

    label = nmf_labels.get(nmf_group, nmf_group)
    color = color_map[nmf_group]

    ax.plot(
        angles,
        values,
        linewidth=2.5,
        linestyle="solid",
        label=f"NMF{nmf_group}: {label}",
        color=color,
    )
    ax.fill(angles, values, color=color, alpha=0.2)

# Format the plot
ax.set_theta_offset(np.pi / 2)
ax.set_theta_direction(-1)

ax.set_xticks(angles[:-1])
ax.set_xticklabels(categories, size=15)
ax.set_yticklabels([])  # Hide radial labels
ax.grid(True, color="grey", alpha=0.3)
ax.spines["polar"].set_visible(False)

ax.legend(loc="upper right", bbox_to_anchor=(1.3, 1.1), fontsize=12)
ax.set_title("Radial plot of NMF groups", size=20, y=1.1)
plt.tight_layout()


plt.show()
{% endhighlight %}

{% include figure.liquid loading="eager" path="assets/img/subtyping/radial.png" class="img-fluid rounded z-depth-1" %}

---
## Citations

---